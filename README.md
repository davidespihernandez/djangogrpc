# djangogrpc

Example of Django application using gRPC to communicate client and server.

Main technologies used:

- **django**
- **django-grpc** package. Is a very recent package, but it works well and saves a lot of time.
- **mixer**. To generate test data.
- **protocol buffers** - grpc. This is the technology we will use for the RPC calls.
- **docker**. For the postgresql database.

## Installation

* Execute docker-compose from the project root folder. This will run a postgres database instance that will contain our tables and data. You need postgres installed on your computer anyway to use `psycopg` package.
* Create a virtual environment, activate it and install all the dependencies (`pip install -r requirements.in`)
* Run the database migrations with `python manage.py migrate`. This command creates the tables we'll use in the tests.

## The example

This is a very simple example, where we define two different applications:

* MSP. Contains a single table, called Token.
* CPO. Contains a single table, called Location.

This applications can be running in different servers, as different django processes. 
The goal is to allow communication between different instances using gRPC.
In order to do that, we have created a new application (which could be a separated application) called `protocol`, that defines all the data types and service calls using the protocol buffers language.

The `.proto` files contained in that application can be used to generate python code for the data types and services, that wil be later used and extended or implemented by other applications.

## Test it

In order to test it, I created some django management commands.

### Generate test data

Execute `python manage.py create_msp_test_data` to create some rows in the msp.Token table. 
These rows are created using mixed, which is a cool python package that integrates very well with Django.

### The implementation
In this example, only the MSP server is working. In the `settings.py` file we find:

```python
GRPCSERVER = {
    'servicers': ['msp.services.msp.grpc_hook'],
    'maximum_concurrent_rpcs': None,
}
```

That indicates the django-grpc package to expose the services defined in that method, which is:

```python
def grpc_hook(server):
    protocol.proto.msp_pb2_grpc.add_TokensServicer_to_server(TokensService(), server)
```

Where that `TokensService()` is the local implementation of the `TokensServicer` defined in the .proto files:

```python
from protocol.proto.msp_pb2_grpc import TokensServicer

class TokensService(TokensServicer):
    ...
```

The MSP local implementation of the service contains methods for each service call. The original proto file defines:

```python
service Tokens {
  rpc GetTokenList(TokenListRequest) returns (stream Token) {}
  rpc GetToken(TokenDetailRequest) returns (Token) {}
  rpc CreateToken(TokenCreationRequest) returns (Token) {}
}
```

And the implementation of this service, using the data structures generated by the protoc compiler, is:

```python
class TokensService(TokensServicer):
    def _model_to_proto(self, token_model: TokenModel):
        date_created = Timestamp()
        date_created.GetCurrentTime()
        date_created.seconds = int(token_model.date_created.timestamp())
        return Token(id=token_model.id, uid=token_model.uid, name=token_model.name, date_created=date_created)

    def GetToken(self, request: TokenDetailRequest, context) -> Token:
        logger.info(f"Called Server GetToken {request}")
        token_model = TokenModel.objects.get(pk=request.id)
        return self._model_to_proto(token_model)

    def GetTokenList(self, request: TokenListRequest, context):
        logger.info(f"Called GetTokenList {request}")
        tokens = TokenModel.objects.all().order_by("pk")[request.offset:request.offset+request.num_items]
        for token_model in tokens:
            yield self._model_to_proto(token_model)

    @transaction.atomic
    def CreateToken(self, request: TokenCreationRequest, context):
        logger.info(f"Called CreateToken {request}")
        token_model = TokenModel.objects.create(
            name=request.name,
            uid=request.uid,
        )
        return self._model_to_proto(token_model)
```

## Start the server 
To start the MSP server, that listens to MSP requests, execute this command:

`python manage.py grpcserver --autoreload` 

The autoreload option is only for development. Once the command is executed, the gRPC server will be listening to request on port 50051 (default)

## Perform requests

To perform requests against the server, open another console and execute one of these commands:

```python
python manage.py send_create_token
python manage.py send_get_token
python manage.py send_get_token_list
```

Each command uses a gRPC client to send requests against the server running in the port 50051.
The request results are printed on the screen. The server also logs the requests.
Notice all requests use the types defined in the proto files, and strict typing is used, which makes things easier later. 

## TODO
* I didn't finish the CPO server, as having the MSP working was good enough to me as example.
* Exception handling has not been implemented. gRPC does that using the context in the RPC call. See https://github.com/grpc/grpc/tree/master/examples/python/errors for more info.

